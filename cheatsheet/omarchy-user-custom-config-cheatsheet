#!/bin/bash

# =============================================================================
# INITIALIZATION & CONFIGURATION
# =============================================================================

# --- Logging Setup ---
LOG_FILE="/tmp/cheatsheet_debug.log"
[ -f "$LOG_FILE" ] && rm -f "$LOG_FILE"
exec 2> "$LOG_FILE"
set -x

# --- File Paths ---
CHEAT_FILE="/home/jebin/git/omarchy_custom_config/cheatsheet/cheatsheet.json"
CONFIG_FILE="/home/jebin/git/omarchy_custom_config/config.toml"
ENV_FILE="/home/jebin/git/omarchy_custom_config/.env"
SYSTEM_PROMPT_FILE="/home/jebin/git/omarchy_custom_config/cheatsheet/system_prompt.md"
DEBOUNCE_PID_FILE="/tmp/cheatsheet_debounce.pid"
RELOAD_FLAG_FILE="/tmp/cheatsheet_reload.flag"

echo "--- Script started at $(date) ---"

# =============================================================================
# VALIDATION & SETUP
# =============================================================================

# --- Validate required files ---
validate_files() {
    local files=("$CHEAT_FILE" "$CONFIG_FILE" "$ENV_FILE" "$SYSTEM_PROMPT_FILE")
    local names=("Cheat file" "Config file" "Environment file" "System prompt file")
    
    for i in "${!files[@]}"; do
        [[ ! -f "${files[$i]}" ]] && echo "ERROR: ${names[$i]} not found at ${files[$i]}" && exit 1
    done
}

# --- Initialize Gemini configuration ---
initialize_gemini_config() {
    grep -q '^SEARCH_WITH_GEMINI=' "$CONFIG_FILE" || echo 'SEARCH_WITH_GEMINI="false"' >> "$CONFIG_FILE"
    
    SEARCH_WITH_GEMINI=$(grep '^SEARCH_WITH_GEMINI=' "$CONFIG_FILE" | sed 's/.*"\(.*\)"/\1/')
    echo "DEBUG: SEARCH_WITH_GEMINI is set to '$SEARCH_WITH_GEMINI'"
    
    if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
        load_api_key
    fi
}

# --- Load and validate API key ---
load_api_key() {
    if [ -f "$ENV_FILE" ]; then
        { set +x; } 2>/dev/null
        set -o allexport; source "$ENV_FILE"; set +o allexport
        { set -x; } 2>/dev/null
    fi

    { set +x; } 2>/dev/null
    if [ -z "$GEMINI_API_KEY" ]; then
        echo "ERROR: GEMINI_API_KEY is not set or found in $ENV_FILE"
        notify-send "Cheatsheet Error" "GEMINI_API_KEY not found!"
        exit 1
    fi
    { set -x; } 2>/dev/null
    
    echo "DEBUG: GEMINI_API_KEY is set."
}

# --- Prepare special menu rows ---
prepare_special_rows() {
    if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
        GEMINI_ROW="[‚úì] Search with Gemini API ‚Üí Toggle Gemini search"
    else
        GEMINI_ROW="[ ] Search with Gemini API ‚Üí Toggle Gemini search"
    fi
    COPY_ALL_ROW="Copy all cheat ‚Üí Copy all cheats to clipboard"
}

# =============================================================================
# STRING MANIPULATION UTILITIES
# =============================================================================

# --- Trim whitespace ---
trim() {
    echo "$1" | xargs
}

# --- Clean selection string ---
clean_selection() {
    local selection="$1"
    selection="$(echo "$selection" | tr -d '\n' | tr -d "'" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    selection="${selection//üí° /}"
    selection="${selection//‚è±Ô∏è /}"
    selection="${selection//üöÄ /}"
    echo "$selection"
}

# =============================================================================
# ID EXTRACTION & MANAGEMENT
# =============================================================================

# --- Extract ID from selection string ---
extract_id() {
    local selection="$1"
    
    if [[ "$selection" = *"Search with Gemini API"* || "$selection" = *"Copy all cheat"* ]]; then
        echo "$selection"
        return 0
    fi
    
    selection=$(clean_selection "$selection")
    
    if [[ "$selection" =~ \[?([0-9]+)\]? ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi
    
    echo "ERROR: Could not extract valid numeric ID" >&2
    return 1
}

# --- Get next available ID ---
get_next_id() {
    local max_id=$(jq '[.[].id] | max // 0' "$CHEAT_FILE")
    echo $((max_id + 1))
}

# --- Check if ID exists ---
id_exists() {
    local id="$1"
    jq -e --argjson id "$id" '.[] | select(.id == $id)' "$CHEAT_FILE" >/dev/null 2>&1
    return $?
}

# =============================================================================
# COMMAND & DESCRIPTION EXTRACTION
# =============================================================================

# --- Extract command from selection string ---
extract_command_from_selection() {
    local selection="$1"
    
    # Step 1: Split by ‚Üí and take first value
    local before_arrow="${selection%%‚Üí*}"
    before_arrow=$(trim "$before_arrow")
    
    echo "DEBUG: After splitting by ‚Üí: '$before_arrow'" >&2
    
    # Step 2: Remove [<number>] pattern if present
    if [[ "$before_arrow" =~ \[[0-9]+\] ]]; then
        before_arrow="${before_arrow##*\[[0-9]*\]}"
        before_arrow=$(trim "$before_arrow")
        echo "DEBUG: After removing [ID]: '$before_arrow'" >&2
    fi
    
    # Step 3: Remove leading emojis
    before_arrow=$(echo "$before_arrow" | sed 's/^[[:space:]]*[üí°‚è±Ô∏èüöÄ‚ùå‚ú®]\+[[:space:]]*//')
    before_arrow=$(trim "$before_arrow")
    
    echo "DEBUG: Final extracted command: '$before_arrow'" >&2
    echo "$before_arrow"
}

# --- Extract description from selection string ---
extract_description_from_selection() {
    local selection="$1"
    
    # Handle Gemini format
    if [[ "$selection" =~ ‚Üí[[:space:]]*(.+)[[:space:]]\(‚ú®[[:space:]]*New\ from\ Gemini\) ]]; then
        local desc="${BASH_REMATCH[1]}"
        echo "$(trim "$desc")"
        return 0
    fi
    
    # Handle standard format
    if [[ "$selection" =~ ‚Üí[[:space:]]*(.+?)$ ]]; then
        local desc="${BASH_REMATCH[1]}"
        desc=$(echo "$desc" | sed 's/[[:space:]]*([‚ú®[:space:]]*New from Gemini[)]$//')
        echo "$(trim "$desc")"
        return 0
    fi
    
    return 1
}

# --- Get command by ID with fallback to selection ---
get_command_by_id() {
    local id="$1"
    local selection="$2"
    
    # Try JSON first
    local cmd=$(jq -r --argjson id "$id" '.[] | select(.id == $id) | .command' "$CHEAT_FILE" 2>/dev/null)
    
    if [[ -n "$cmd" ]]; then
        echo "$cmd"
        return 0
    fi
    
    # Fallback to selection extraction
    if [[ -n "$selection" ]]; then
        echo "DEBUG: ID $id not found in file, extracting from selection" >&2
        cmd=$(extract_command_from_selection "$selection")
        
        if [[ -n "$cmd" ]]; then
            echo "$cmd"
            return 0
        fi
    fi
    
    return 1
}

# --- Get description by ID with fallback to selection ---
get_description_by_id() {
    local id="$1"
    local selection="$2"
    
    # Try JSON first
    local desc=$(jq -r --argjson id "$id" '.[] | select(.id == $id) | .description' "$CHEAT_FILE" 2>/dev/null)
    
    if [[ -n "$desc" ]]; then
        echo "$desc"
        return 0
    fi
    
    # Fallback to selection extraction
    if [[ -n "$selection" ]]; then
        echo "DEBUG: ID $id not found in file, extracting description from selection" >&2
        desc=$(extract_description_from_selection "$selection")
        
        if [[ -n "$desc" ]]; then
            echo "$desc"
            return 0
        fi
    fi
    
    return 1
}

# =============================================================================
# JSON MANIPULATION
# =============================================================================

# --- Add command to JSON ---
add_to_json() {
    local cmd="$1"
    local desc="$2"
    
    echo "DEBUG: Adding to JSON - cmd: '$cmd', desc: '$desc'" >&2
    
    # Check if command already exists
    local existing_id=$(jq -r --arg cmd "$cmd" '.[] | select(.command == $cmd) | .id' "$CHEAT_FILE" 2>/dev/null)
    
    if [[ -n "$existing_id" ]]; then
        edit_in_json "$existing_id" "$cmd" "$desc"
        return 1
    fi
    
    local next_id=$(get_next_id)
    
    jq --argjson id "$next_id" --arg cmd "$cmd" --arg desc "$desc" \
       '. += [{"id": $id, "command": $cmd, "description": $desc}]' \
       "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Added: $cmd ‚úÖ (ID: $next_id)"
    echo "DEBUG: Successfully added to JSON with ID: $next_id" >&2
}

# --- Edit command in JSON by ID ---
edit_in_json() {
    local id="$1"
    local cmd="$2"
    local desc="$3"
    
    echo "DEBUG: Editing in JSON - id: $id, cmd: '$cmd', desc: '$desc'" >&2
    
    if ! id_exists "$id"; then
        echo "ERROR: ID '$id' not found in cheatsheet" >&2
        notify-send "Cheatsheet Error" "ID not found: $id"
        return 1
    fi
    
    jq --argjson id "$id" --arg cmd "$cmd" --arg desc "$desc" \
       'map(if .id == $id then .command = $cmd | .description = $desc else . end)' \
       "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Updated ID $id ‚úÖ"
    echo "DEBUG: Successfully updated ID: $id" >&2
}

# --- Delete command from JSON by ID ---
delete_from_json() {
    local selection="$1"
    local id_to_delete=$(extract_id "$selection")
    
    echo "DEBUG: Raw selection: '$selection'" >&2
    echo "DEBUG: Extracted ID for deletion: '$id_to_delete'" >&2
    
    if [[ -z "$id_to_delete" || ! "$id_to_delete" =~ ^[0-9]+$ ]]; then
        echo "ERROR: Could not extract valid numeric ID" >&2
        notify-send "Cheatsheet Error" "Could not extract ID from selection"
        return 1
    fi
    
    if ! id_exists "$id_to_delete"; then
        echo "ERROR: ID '$id_to_delete' not found for deletion" >&2
        notify-send "Cheatsheet Error" "ID not found: $id_to_delete"
        return 1
    fi
    
    local cmd_name=$(get_command_by_id "$id_to_delete" "$selection" | head -c 50)
    
    jq --argjson id "$id_to_delete" 'del(.[] | select(.id == $id))' \
       "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Deleted ID $id_to_delete: $cmd_name... ‚úÖ"
    echo "DEBUG: Successfully deleted ID: $id_to_delete" >&2
}

# =============================================================================
# MENU BUILDING
# =============================================================================

# --- Build static menu ---
build_static_menu() {
    {
        printf '%s\n' "$GEMINI_ROW"
        printf '%s\n' "$COPY_ALL_ROW"
        jq -r '.[] | "[\(.id)] \(.command) ###‚Üí \(.description)"' "$CHEAT_FILE" | while IFS= read -r line; do
            printf '%s\n' "$line"
        done
    } | column -t -s '###'
}

# =============================================================================
# SPECIAL COMMAND HANDLERS
# =============================================================================

# --- Parse /add command ---
parse_add_command() {
    local query="$1"
    
    if [[ "$query" =~ ^(.+)[[:space:]]*###[[:space:]]*(.+)$ ]]; then
        local cmd=$(trim "${BASH_REMATCH[1]}")
        local desc=$(trim "${BASH_REMATCH[2]}")
        
        add_to_json "$cmd" "$desc"
        touch "$RELOAD_FLAG_FILE"
        build_static_menu
        return 0
    fi
    
    echo "‚ùå Invalid format. Use: /add <command> ### <description>"
    return 1
}

# --- Parse /edit command ---
parse_edit_command() {
    local query="$1"
    
    if [[ "$query" =~ ^([0-9]+)[[:space:]]*###[[:space:]]*(.+)[[:space:]]*###[[:space:]]*(.+)$ ]]; then
        local id="${BASH_REMATCH[1]}"
        local cmd=$(trim "${BASH_REMATCH[2]}")
        local desc=$(trim "${BASH_REMATCH[3]}")
        
        edit_in_json "$id" "$cmd" "$desc"
        touch "$RELOAD_FLAG_FILE"
        build_static_menu
        return 0
    fi
    
    echo "‚ùå Invalid format. Use: /edit <ID> ### <command> ### <description>"
    return 1
}

# --- Handle special commands ---
handle_special_commands() {
    local query="$1"
    
    if [[ "$query" =~ ^/add[[:space:]]+ ]]; then
        parse_add_command "${query#/add }"
        return 0
    fi

    if [[ "$query" =~ ^/edit[[:space:]]+ ]]; then
        parse_edit_command "${query#/edit }"
        return 0
    fi
    
    return 1
}

# --- Handle non-Gemini mode filtering ---
handle_non_gemini_change() {
    local query="$1"
    handle_special_commands "$query" && return
    build_static_menu | grep -i --color=never -E "$query"
}

# =============================================================================
# PROCESS MANAGEMENT
# =============================================================================

# --- Kill existing search process ---
kill_existing_search() {
    if [[ -f "$DEBOUNCE_PID_FILE" ]]; then
        local old_pid=$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)
        if [[ -n "$old_pid" ]] && kill -0 "$old_pid" 2>/dev/null; then
            echo "DEBUG: Cancelling previous search (PID: $old_pid)" >&2
            kill "$old_pid" 2>/dev/null || true
            pkill -P "$old_pid" 2>/dev/null || true
        fi
        rm -f "$DEBOUNCE_PID_FILE"
    fi
}

# =============================================================================
# GEMINI SEARCH
# =============================================================================

# --- Format Gemini result ---
format_gemini_result() {
    local cmd="$1"
    local desc="$2"
    local query="$3"
    
    # Check if command exists in JSON
    local existing_desc=$(jq -r --arg cmd "$cmd" '.[] | select(.command == $cmd) | .description' "$CHEAT_FILE" 2>/dev/null)
    
    if [[ -n "$existing_desc" ]]; then
        printf 'üí° %s ‚Üí %s\n' "$cmd" "$existing_desc"
    else
        desc="${desc:-$query}"
        if [[ -n "$desc" ]]; then
            local next_id=$(get_next_id)
            printf "üí° [%s] %s ‚Üí %s (‚ú® New from Gemini)\n" "$next_id" "$cmd" "$desc"
        else
            printf 'üí° %s\n' "$cmd"
        fi
    fi
}

# --- Gemini search function ---
gemini_search() {
    local query="$1"

    [[ -z "$query" || ${#query} -lt 3 ]] && return

    echo "üîç Searching with Gemini: '$query'" >&2

    if [[ ! -f "$SYSTEM_PROMPT_FILE" ]]; then
        echo "ERROR: System prompt file not found!" >&2
        printf '‚ùå ERROR: System prompt file not found\n'
        return
    fi
    
    local SYSTEM_PROMPT=$(<"$SYSTEM_PROMPT_FILE")
    echo "DEBUG: System prompt loaded (${#SYSTEM_PROMPT} chars)" >&2

    local JSON_PAYLOAD=$(jq -n \
                  --arg sp "$SYSTEM_PROMPT" \
                  --arg q "$query" \
                  '{contents: [{parts: [{text: $sp}, {text: "User query: " + $q}]}]}')

    echo "DEBUG: Making API call..." >&2
    local API_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
        --max-time 10 \
        -H 'Content-Type: application/json' \
        -d "$JSON_PAYLOAD" \
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" 2>&2)

    if [[ $? -eq 143 ]] || [[ $? -eq 130 ]]; then
        echo "DEBUG: API call was cancelled" >&2
        printf '‚ùå Request cancelled - new search started\n'
        return
    fi

    local HTTP_BODY=$(echo "$API_RESPONSE" | sed '$d')
    local HTTP_STATUS=$(echo "$API_RESPONSE" | tail -n1 | cut -d: -f2)

    echo "DEBUG: HTTP Status: $HTTP_STATUS" >&2

    if [[ "$HTTP_STATUS" -ne 200 ]]; then
        echo "ERROR: API Error (Status: $HTTP_STATUS)" >&2
        printf '--- ‚ùå Gemini API Error (Status: %s) ---\n' "$HTTP_STATUS"
        return
    fi

    local gemini_output=$(echo "$HTTP_BODY" | jq -r '.candidates[0].content.parts[0].text // empty' 2>&2)
    echo "DEBUG: Gemini output length: ${#gemini_output} chars" >&2

    if [[ -n "$gemini_output" ]]; then
        local json_content=$(echo "$gemini_output" | sed -n '/```json/,/```/p' | sed '1d;$d')

        if [[ -n "$json_content" ]]; then
            local cmd=$(echo "$json_content" | jq -r '.cmd // empty' 2>&2)
            echo "DEBUG: Parsed cmd: $cmd" >&2

            if [[ -n "$cmd" ]]; then
                local gemini_desc=$(echo "$json_content" | jq -r '.description // empty' 2>&2)
                format_gemini_result "$cmd" "$gemini_desc" "$query"
            else
                printf '--- ‚ö†Ô∏è Could not parse command from Gemini response ---\n'
            fi
        else
            printf '--- ü§ñ Gemini Suggestions for "%s" ---\n' "$query"
            echo "$gemini_output" | while IFS= read -r line; do
                [[ -n "$line" ]] && printf 'üí° %s\n' "$line"
            done
            printf '--- End Gemini Results ---\n'
        fi
    else
        printf '--- ‚ö†Ô∏è No results from Gemini ---\n'
    fi
}

# --- Debounced Gemini search wrapper ---
debounced_gemini_search() {
    local query="$1"
    local debounce_delay=2

    handle_special_commands "$query" && return

    # Handle empty query
    if [[ -z "$query" || "$query" =~ ^[[:space:]]*$ ]]; then
        echo "DEBUG: Query empty ‚Äî showing static menu" >&2
        kill_existing_search
        build_static_menu
        return
    fi

    kill_existing_search

    # Start new search in background
    (
        local search_pid=$$
        echo "$search_pid" > "$DEBOUNCE_PID_FILE"

        printf '‚è±Ô∏è  Will search Gemini in %ds for: "%s"\n' "$debounce_delay" "$query"
        sleep "$debounce_delay"

        local current_pid=$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)
        if [[ "$search_pid" != "$current_pid" ]]; then
            echo "DEBUG: Search cancelled (newer search started)" >&2
            printf '\033[1A\033[K‚ùå Cancelled - new search started\n'
            exit 0
        fi

        printf '\033[1A\033[KüöÄ Request sent to Gemini API - Processing: "%s"\n' "$query"
        local gemini_results=$(gemini_search "$query")
        printf '\033[1A\033[K%s\n' "$gemini_results"

        [[ "$search_pid" == "$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)" ]] && rm -f "$DEBOUNCE_PID_FILE"
    ) &
}

# =============================================================================
# EXPORT FUNCTIONS
# =============================================================================

export -f extract_id get_next_id get_command_by_id get_description_by_id id_exists parse_add_command parse_edit_command
export -f gemini_search debounced_gemini_search build_static_menu format_gemini_result
export -f add_to_json edit_in_json delete_from_json
export -f handle_special_commands handle_non_gemini_change
export -f trim clean_selection extract_command_from_selection extract_description_from_selection
export GEMINI_API_KEY SYSTEM_PROMPT_FILE LOG_FILE DEBOUNCE_PID_FILE
export CHEAT_FILE GEMINI_ROW COPY_ALL_ROW RELOAD_FLAG_FILE

# =============================================================================
# FZF CONFIGURATION
# =============================================================================

build_fzf_preview() {
    cat <<'EOF'
selection={};
if [[ ! "$selection" =~ (‚è±Ô∏è|üöÄ|‚ùå) ]]; then
  id=$(extract_id "$selection")
  
  if [[ -n "$id" ]] && [[ "$id" =~ ^[0-9]+$ ]]; then
    cmd=$(get_command_by_id "$id" "$selection")
    description=$(get_description_by_id "$id" "$selection")
    
    printf "üÜî ID: %s\n" "$id"
    printf "üìù Description: %s\n" "$description"
    printf "\n\n"
    
    main_cmd=$(printf "%s" "$cmd" | awk "{print \$1}" | sed "s/^sudo //")
    if [[ "$selection" != *"Search with Gemini API"* && "$selection" != *"Copy all cheat"* ]]; then
      printf "üìñ Man Page: %s\n\n" "$main_cmd"
      man "$main_cmd" 2>/dev/null || printf "No manual entry for %s\n" "$main_cmd"
    fi
  fi
fi
EOF
}

fzf_common_args=(
  --preview "$(build_fzf_preview)"
  --preview-label='[ID] Desc + man | alt-p: toggle | ctrl-e: edit | ctrl-d: delete'
  --preview-label-pos='bottom'
  --preview-window 'down:65%:wrap'
  --bind 'alt-p:toggle-preview'
  --bind 'alt-d:preview-half-page-down,alt-u:preview-half-page-up'
  --bind 'alt-k:preview-up,alt-j:preview-down'
  --bind 'ctrl-e:transform-query(id=$(extract_id "{}"); jq -r --argjson id "$id" ".[] | select(.id == \$id) | \"/edit \" + (.id|tostring) + \" ### \" + .command + \" ### \" + .description" "'"$CHEAT_FILE"'")'
  --bind 'ctrl-D:execute(delete_from_json "{}" 2>>"'"$LOG_FILE"'")+reload(build_static_menu)'
  --color 'pointer:green,marker:green'
  --no-multi
  --header 'Enter: copy | /add <cmd> ### <desc> | Ctrl-e: edit | Ctrl-d: delete'
)

configure_fzf_mode() {
    if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
        fzf_args=(
          "${fzf_common_args[@]}"
          --disabled
          --bind "start:reload:build_static_menu"
          --bind "change:reload:debounced_gemini_search {q} 2>>$LOG_FILE || true"
          --prompt 'ü§ñ Gemini Search> '
          --ansi
          --header-lines=0
        )
    else
        fzf_args=(
          "${fzf_common_args[@]}"
          --disabled
          --bind "start:reload:build_static_menu"
          --bind "change:reload:handle_non_gemini_change {q} 2>>$LOG_FILE || true"
          --prompt 'Cheatsheet> '
        )
    fi
}

# =============================================================================
# SELECTION HANDLERS
# =============================================================================

# --- Handle Gemini toggle ---
handle_gemini_toggle() {
    echo "DEBUG: Handling Gemini toggle."
    if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
        sed -i 's/SEARCH_WITH_GEMINI *= *.*/SEARCH_WITH_GEMINI="false"/' "$CONFIG_FILE"
        notify-send "Cheatsheet" "Gemini search disabled ‚úÖ"
    else
        sed -i 's/SEARCH_WITH_GEMINI *= *.*/SEARCH_WITH_GEMINI="true"/' "$CONFIG_FILE"
        notify-send "Cheatsheet" "Gemini search enabled ‚úÖ"
    fi
    exec "$0"
}

# --- Handle copy all ---
handle_copy_all() {
    echo "DEBUG: Handling 'Copy all cheats'."
    jq '.' "$CHEAT_FILE" | wl-copy
    notify-send "Cheatsheet" "All cheats copied to clipboard ‚úÖ"
    exit 0
}

# --- Handle command copy ---
handle_command_copy() {
    local selection="$1"
    local selected_id=$(extract_id "$selection")
    
    if [[ -n "$selected_id" ]] && [[ "$selected_id" =~ ^[0-9]+$ ]]; then
        echo "DEBUG: Selected ID: $selected_id"
        
        local command=$(get_command_by_id "$selected_id" "$selection")
        local description=$(get_description_by_id "$selected_id" "$selection")
        
        if [[ -n "$command" ]]; then
            printf '%s' "$command" | wl-copy
            
            # Auto-add Gemini results
            if [[ "$selection" =~ "New from Gemini" ]]; then
                add_to_json "$command" "$description"
            fi
            
            notify-send "Cheatsheet" "Command copied (ID: $selected_id) ‚úÖ"
            echo "DEBUG: Copied command for ID $selected_id" >&2
        else
            echo "ERROR: Command not found for ID: $selected_id" >&2
            notify-send "Cheatsheet Error" "Command not found for ID: $selected_id"
        fi
    fi
}

# --- Process selection ---
process_selection() {
    local selection="$1"
    
    [[ -z "$selection" ]] && return 1
    
    echo "DEBUG: User selected: '$selection'"
    
    [[ "$selection" =~ "Search with Gemini API" ]] && handle_gemini_toggle
    [[ "$selection" =~ ^"Copy all cheat" ]] && handle_copy_all
    
    handle_command_copy "$selection"
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    validate_files
    initialize_gemini_config
    prepare_special_rows
    configure_fzf_mode
    
    rm -f "$RELOAD_FLAG_FILE"
    
    local selection=$(fzf "${fzf_args[@]}")
    
    rm -f "$DEBOUNCE_PID_FILE"
    
    if [[ -z "$selection" ]]; then
        echo "DEBUG: No selection made. Exiting."
        [ -f "$RELOAD_FLAG_FILE" ] && rm -f "$RELOAD_FLAG_FILE" && exec "$0"
        exit 0
    fi
    
    [ -f "$RELOAD_FLAG_FILE" ] && rm -f "$RELOAD_FLAG_FILE" && exec "$0"
    
    process_selection "$selection"
    
    echo "--- Script finished at $(date) ---"
}

main
set +x