#!/bin/bash

# -----------------------------------------------------------------------------
# DEBUGGING:
# Enable verbose output, printing each command as it's executed.
# All debug output (from set -x) and our custom log messages (to stderr)
# will be redirected to the log file defined below.
# -----------------------------------------------------------------------------
LOG_FILE="/tmp/cheatsheet_debug.log"
[ -f "$LOG_FILE" ] && rm -f "$LOG_FILE"
exec 2> "$LOG_FILE" # Redirect stderr to the log file
set -x             # Print commands and their arguments as they are executed.
# -----------------------------------------------------------------------------

# --- Configuration ---
CHEAT_FILE="/home/jebin/git/omarchy_custom_config/cheatsheet/cheatsheet.json"
CONFIG_FILE="/home/jebin/git/omarchy_custom_config/config.toml"
ENV_FILE="/home/jebin/git/omarchy_custom_config/.env" #contains secret keys like GEMINI_API_KEY
SYSTEM_PROMPT_FILE="/home/jebin/git/omarchy_custom_config/cheatsheet/system_prompt.md"
DEBOUNCE_PID_FILE="/tmp/cheatsheet_debounce.pid"
RELOAD_FLAG_FILE="/tmp/cheatsheet_reload.flag" ### ADDED ### Flag file for reloading

echo "--- Script started at $(date) ---"

# --- File Checks ---
[[ ! -f "$CHEAT_FILE" ]] && echo "ERROR: Cheat file not found at $CHEAT_FILE" && exit 1
[[ ! -f "$CONFIG_FILE" ]] && echo "ERROR: Config file not found at $CONFIG_FILE" && exit 1
[[ ! -f "$ENV_FILE" ]] && echo "ERROR: Environment file not found at $ENV_FILE" && exit 1
[[ ! -f "$SYSTEM_PROMPT_FILE" ]] && echo "ERROR: System prompt file not found at $SYSTEM_PROMPT_FILE" && exit 1

# --- Setup ---
# Ensure Gemini toggle exists in config
grep -q '^SEARCH_WITH_GEMINI=' "$CONFIG_FILE" || echo 'SEARCH_WITH_GEMINI="false"' >> "$CONFIG_FILE"

# Read current GEMINI toggle - ROBUST METHOD
SEARCH_WITH_GEMINI=$(grep '^SEARCH_WITH_GEMINI=' "$CONFIG_FILE" | sed 's/.*"\(.*\)"/\1/')
echo "DEBUG: SEARCH_WITH_GEMINI is set to '$SEARCH_WITH_GEMINI'"

# Source environment variables to get API key (if Gemini enabled)
if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
    if [ -f "$ENV_FILE" ]; then
        { set +x; } 2>/dev/null
        set -o allexport; source "$ENV_FILE"; set +o allexport
        { set -x; } 2>/dev/null
    fi

    # Temporarily disable debugging to check the variable safely
    { set +x; } 2>/dev/null
    if [ -z "$GEMINI_API_KEY" ]; then
        echo "ERROR: GEMINI_API_KEY is not set or found in $ENV_FILE"
        notify-send "Cheatsheet Error" "GEMINI_API_KEY not found!"
        exit 1
    fi
    { set -x; } 2>/dev/null

    echo "DEBUG: GEMINI_API_KEY is set."  # ‚úÖ safe to log, no value shown
fi


# Prepare special rows
if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
    GEMINI_ROW="[‚úì] Search with Gemini API ‚Üí Toggle Gemini search"
else
    GEMINI_ROW="[ ] Search with Gemini API ‚Üí Toggle Gemini search"
fi
COPY_ALL_ROW="Copy all cheat ‚Üí Copy all cheats to clipboard"

# --- Menu Functions ---
build_static_menu() {
    {
        echo "$GEMINI_ROW"
        echo "$COPY_ALL_ROW"
        jq -r '.[] | "\(.command) ###‚Üí \(.description)"' "$CHEAT_FILE"
    } | column -t -s '###'
}

# --- Function to add command to JSON ---
add_to_json() {
    local cmd="$1"
    local desc="$2"
    
    echo "DEBUG: Adding to JSON - cmd: '$cmd', desc: '$desc'" >&2
    
    # Check if command already exists
    if jq -e --arg cmd "$cmd" '.[] | select(.command == $cmd)' "$CHEAT_FILE" > /dev/null 2>&1; then
        edit_in_json "$1" "$2"
        return 1
    fi
    
    # Add new entry to JSON
    jq --arg cmd "$cmd" --arg desc "$desc" '. += [{"command": $cmd, "description": $desc}]' "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Added: $cmd ‚úÖ"
    echo "DEBUG: Successfully added to JSON" >&2
}

# --- Function to edit command in JSON ---
edit_in_json() {
    local cmd="$1"
    local desc="$2"
    
    echo "DEBUG: Editing in JSON - cmd: '$cmd', desc: '$desc'" >&2
    
    # Check if command exists
    if ! jq -e --arg cmd "$cmd" '.[] | select(.command == $cmd)' "$CHEAT_FILE" > /dev/null 2>&1; then
        echo "ERROR: Command '$cmd' not found in cheatsheet" >&2
        notify-send "Cheatsheet Error" "Command not found: $cmd"
        return 1
    fi
    
    # Update the entry in JSON
    jq --arg cmd "$cmd" --arg desc "$desc" 'map(if .command == $cmd then .description = $desc else . end)' "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Updated: $cmd ‚úÖ"
    echo "DEBUG: Successfully updated in JSON" >&2
}

# --- NEW: Function to delete command from JSON ---
delete_from_json() {
    local selection="$1"
    
    # Extract the command part (before the arrow)
    cmd_to_delete="${selection#\'}"      # remove leading ' if present
    cmd_to_delete="${cmd_to_delete%%‚Üí*}"  # everything before ‚Üí
    cmd_to_delete="$(echo "$cmd_to_delete" | xargs)"  # trim leading/trailing spaces
    
    echo "DEBUG: Deleting from JSON - cmd: '$cmd_to_delete'" >&2
    
    # Check if the command exists in the JSON
    if ! jq -e --arg cmd "$cmd_to_delete" '.[] | select(.command == $cmd)' "$CHEAT_FILE" > /dev/null 2>&1; then
        echo "ERROR: Command '$cmd_to_delete' not found for deletion" >&2
        notify-send "Cheatsheet Error" "Command not found for deletion: $cmd_to_delete"
        return 1
    fi
    
    # Delete the entry from JSON
    jq --arg cmd "$cmd_to_delete" 'del(.[] | select(.command == $cmd))' "$CHEAT_FILE" > "${CHEAT_FILE}.tmp" && mv "${CHEAT_FILE}.tmp" "$CHEAT_FILE"
    
    notify-send "Cheatsheet" "Deleted: $cmd_to_delete ‚úÖ"
    echo "DEBUG: Successfully deleted from JSON" >&2
}

# --- Shared command handler for /add and /edit ---
# Returns 0 if a command was handled, 1 otherwise.
handle_special_commands() {
    local query="$1"

    ### MODIFIED ### Removed NEED_RELOAD logic from here
    
    # --- Handle /add command ---
    if [[ "$query" =~ ^/add[[:space:]]+ ]]; then
        query="${query#/add }"
        if [[ "$query" =~ ^(.+)[[:space:]]*###[[:space:]]*(.+)$ ]]; then
            local cmd="${BASH_REMATCH[1]}"
            cmd=$(echo "$cmd" | xargs)  # trim whitespace
            local desc="${BASH_REMATCH[2]}"
            desc=$(echo "$desc" | xargs)  # trim whitespace
            
            add_to_json "$cmd" "$desc"
            touch "$RELOAD_FLAG_FILE" ### ADDED ### Create flag file on success
            build_static_menu
        else
            echo "‚ùå Invalid format. Use: /add <command> ### <description>"
        fi
        return 0 # Command was handled
    fi

    # --- Handle /edit command ---
    if [[ "$query" =~ ^/edit[[:space:]]+ ]]; then
        query="${query#/edit }"
        if [[ "$query" =~ ^(.+)[[:space:]]*###[[:space:]]*(.+)$ ]]; then
            local cmd="${BASH_REMATCH[1]}"
            cmd=$(echo "$cmd" | xargs)  # trim whitespace
            local desc="${BASH_REMATCH[2]}"
            desc=$(echo "$desc" | xargs)  # trim whitespace
            
            edit_in_json "$cmd" "$desc"
            touch "$RELOAD_FLAG_FILE" ### ADDED ### Create flag file on success
            build_static_menu
        else
            echo "‚ùå Invalid format. Use: /edit <command> ### <description>"
        fi
        return 0 # Command was handled
    fi
    
    return 1 # No special command was handled
}

# --- Debounced Gemini Search Wrapper ---
debounced_gemini_search() {
    local query="$1"
    local debounce_delay=2

    # Handle special commands first
    handle_special_commands "$query" && return

    # --- Handle empty query ---
    if [[ -z "$query" || "$query" =~ ^[[:space:]]*$ ]]; then
        echo "DEBUG: Query empty ‚Äî showing static menu" >&2

        # Cancel any pending debounce job
        if [[ -f "$DEBOUNCE_PID_FILE" ]]; then
            old_pid=$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)
            if [[ -n "$old_pid" ]] && kill -0 "$old_pid" 2>/dev/null; then
                kill "$old_pid" 2>/dev/null || true
                pkill -P "$old_pid" 2>/dev/null || true
            fi
            rm -f "$DEBOUNCE_PID_FILE"
        fi

        # Immediately reload the static cheatsheet
        build_static_menu
        return
    fi

    # Kill any existing search process
    if [[ -f "$DEBOUNCE_PID_FILE" ]]; then
        old_pid=$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)
        if [[ -n "$old_pid" ]] && kill -0 "$old_pid" 2>/dev/null; then
            echo "DEBUG: Cancelling previous search (PID: $old_pid)" >&2
            kill "$old_pid" 2>/dev/null || true
            # Kill the entire process group to ensure curl is also killed
            pkill -P "$old_pid" 2>/dev/null || true
        fi
    fi

    # Start new search in background and save its PID
    (
        search_pid=$$
        echo "$search_pid" > "$DEBOUNCE_PID_FILE"

        # 1. Print initial status
        echo "‚è±Ô∏è  Will search Gemini in ${debounce_delay}s for: \"$query\""

        # Debounce delay - wait for typing to stop
        sleep "$debounce_delay"

        # Check if we're still the current search
        current_pid=$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)
        if [[ "$search_pid" != "$current_pid" ]]; then
            echo "DEBUG: Search cancelled (newer search started)" >&2
            # Clear the "Will search" message
            echo -e "\033[1A\033[K‚ùå Cancelled - new search started"
            exit 0
        fi

        # 2. Update status to "Request sent" IN-PLACE using ANSI codes
        echo -e "\033[1A\033[KüöÄ Request sent to Gemini API - Processing: \"$query\""

        # 3. Perform the actual search and capture the output
        gemini_results=$(gemini_search "$query")

        # 4. Replace the "Request sent" status with the final results
        echo -e "\033[1A\033[K$gemini_results"

        # Clean up PID file if we're still current
        if [[ "$search_pid" == "$(cat "$DEBOUNCE_PID_FILE" 2>/dev/null)" ]]; then
            rm -f "$DEBOUNCE_PID_FILE"
        fi
    ) &
}

# --- Gemini Search Function ---
gemini_search() {
    local query="$1"

    # If query is empty or too short, return nothing
    if [[ -z "$query" || ${#query} -lt 3 ]]; then
        return
    fi

    echo "üîç Searching with Gemini: '$query'" >&2
    echo "DEBUG: GEMINI_API_KEY detected (hidden for security)" >&2
    echo "DEBUG: System prompt file: $SYSTEM_PROMPT_FILE" >&2

    # Read the system prompt
    if [[ ! -f "$SYSTEM_PROMPT_FILE" ]]; then
        echo "ERROR: System prompt file not found!" >&2
        echo "‚ùå ERROR: System prompt file not found"
        return
    fi
    SYSTEM_PROMPT=$(<"$SYSTEM_PROMPT_FILE")
    echo "DEBUG: System prompt loaded (${#SYSTEM_PROMPT} chars)" >&2

    # Create JSON payload
    JSON_PAYLOAD=$(jq -n \
                  --arg sp "$SYSTEM_PROMPT" \
                  --arg q "$query" \
                  '{contents: [{parts: [{text: $sp}, {text: "User query: " + $q}]}]}')

    echo "DEBUG: JSON payload created (${#JSON_PAYLOAD} chars)" >&2

    # Make the API call to Gemini with timeout
    echo "DEBUG: Making API call..." >&2
    API_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
        --max-time 10 \
        -H 'Content-Type: application/json' \
        -d "$JSON_PAYLOAD" \
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" 2>&2)

    # Check if curl was killed (happens when debounce cancels)
    if [[ $? -eq 143 ]] || [[ $? -eq 130 ]]; then
        echo "DEBUG: API call was cancelled" >&2
        echo "‚ùå Request cancelled - new search started"
        return
    fi

    echo "DEBUG: API call completed" >&2

    # Separate body and status
    HTTP_BODY=$(echo "$API_RESPONSE" | sed '$d')
    HTTP_STATUS=$(echo "$API_RESPONSE" | tail -n1 | cut -d: -f2)

    echo "DEBUG: HTTP Status: $HTTP_STATUS" >&2

    if [[ "$HTTP_STATUS" -ne 200 ]]; then
        echo "ERROR: API Error (Status: $HTTP_STATUS)" >&2
        echo "ERROR: Response body: $HTTP_BODY" >&2
        echo "--- ‚ùå Gemini API Error (Status: $HTTP_STATUS) ---"
        return
    fi

    # Parse the response
    gemini_output=$(echo "$HTTP_BODY" | jq -r '.candidates[0].content.parts[0].text // empty' 2>&2)

    echo "DEBUG: Gemini output length: ${#gemini_output} chars" >&2
    echo "DEBUG: Raw Gemini output: $gemini_output" >&2

    if [[ -n "$gemini_output" ]]; then
        # Extract JSON from markdown code blocks (```json ... ```)
        json_content=$(echo "$gemini_output" | sed -n '/```json/,/```/p' | sed '1d;$d')

        echo "DEBUG: Extracted JSON: $json_content" >&2

        if [[ -n "$json_content" ]]; then
            # Parse the cmd from JSON
            cmd=$(echo "$json_content" | jq -r '.cmd // empty' 2>&2)
            echo "DEBUG: Parsed cmd: $cmd" >&2

            if [[ -n "$cmd" ]]; then
                # Look up the command in the cheatsheet.json for description
                desc=$(jq -r --arg cmd "$cmd" '.[] | select(.command == $cmd) | .description' "$CHEAT_FILE" 2>/dev/null)

                if [[ -n "$desc" ]]; then
                    echo "üí° $cmd ‚Üí $desc"
                else
                    # NEW: If command not found in JSON, add it with Gemini's description
                    gemini_desc=$(echo "$json_content" | jq -r '.description // empty' 2>&2)
                    # If gemini_desc is empty, use $query
                    gemini_desc="${gemini_desc:-$query}"

                    if [[ -n "$gemini_desc" ]]; then
                        echo "DEBUG: Adding Gemini result to JSON" >&2
                        add_to_json "$cmd" "$gemini_desc"
                        echo "üí° $cmd ‚Üí $gemini_desc (‚ú® New from Gemini)"
                    else
                        echo "üí° $cmd"
                    fi
                fi
            else
                echo "--- ‚ö†Ô∏è Could not parse command from Gemini response ---"
            fi
        else
            # Fallback: show raw output if not JSON format
            echo "--- ü§ñ Gemini Suggestions for '$query' ---"
            echo "$gemini_output" | while IFS= read -r line; do
                [[ -n "$line" ]] && echo "üí° $line"
            done
            echo "--- End Gemini Results ---"
        fi
    else
        echo "--- ‚ö†Ô∏è No results from Gemini ---"
    fi
}

# --- Function to handle input in non-Gemini mode ---
handle_non_gemini_change() {
    local query="$1"

    # Handle /add or /edit first
    handle_special_commands "$query" && return

    # Filter static menu with current query
    build_static_menu | grep -i --color=never -E "$query"
}

# Export functions and variables for fzf to use
export -f gemini_search
export -f debounced_gemini_search
export -f build_static_menu
export -f add_to_json
export -f edit_in_json
export -f delete_from_json
export -f handle_special_commands
export -f handle_non_gemini_change
export GEMINI_API_KEY
export SYSTEM_PROMPT_FILE
export LOG_FILE
export DEBOUNCE_PID_FILE
export CHEAT_FILE
export GEMINI_ROW
export COPY_ALL_ROW
export RELOAD_FLAG_FILE ### ADDED ### Export the flag file variable

# --- Common FZF arguments for both modes ---
# NEW: Added ctrl-D binding for delete functionality
fzf_common_args=(
  --preview '
    selection=$(echo {});
    if [[ ! "$selection" =~ (‚è±Ô∏è|üöÄ|‚ùå) ]]; then
      selection="${selection#üí° }"
      description=$(awk -F "‚Üí" "{print \$2}" <<< "$selection")
      cmd_part=$(awk -F "‚Üí" "{print \$1}" <<< "$selection")
      cmd=$(xargs <<< "$cmd_part")

      echo "üìù Description: $description";
      echo ""; echo "";
      main_cmd=$(echo "$cmd" | awk "{print \$1}" | sed "s/^sudo //");
      if [[ "$selection" != *"Search with Gemini API"* && "$selection" != *"Copy all cheat"* ]]; then
        echo "üìñ Man Page: $main_cmd";
        echo "";
        man "$main_cmd" 2>/dev/null || echo "No manual entry for $main_cmd";
      fi
    fi'
  --preview-label='Desc + man | alt-p: toggle, alt-j/k: scroll | ctrl-D: delete'
  --preview-label-pos='bottom'
  --preview-window 'down:65%:wrap'
  --bind 'alt-p:toggle-preview'
  --bind 'alt-d:preview-half-page-down,alt-u:preview-half-page-up'
  --bind 'alt-k:preview-up,alt-j:preview-down'
  --bind 'ctrl-e:transform-query(echo {} | grep -vE "Search with Gemini API|Copy all cheat" | sed "s/  *‚Üí/ ‚Üí/" | sed "s/‚Üí/###/" | sed "s/^/\/edit /")'
  --bind 'ctrl-D:execute(delete_from_json "{}" 2>>$LOG_FILE)+reload(build_static_menu)'
  --color 'pointer:green,marker:green'
  --no-multi
  --header 'Enter: copy | /add <cmd> ### <desc> | Ctrl-e: edit | Ctrl-d: delete'
)

# --- FZF with dynamic reload based on mode ---
if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
    fzf_args=(
      "${fzf_common_args[@]}"
      --disabled
      --bind "start:reload:build_static_menu"
      --bind "change:reload:debounced_gemini_search {q} 2>>$LOG_FILE || true"
      --prompt 'ü§ñ Gemini Search> '
      --ansi # IMPORTANT: Enable processing of ANSI escape codes
      --header-lines=0
    )
else
    # MODIFIED: Non-Gemini mode now also uses reload for interactive /add and /edit
    fzf_args=(
    "${fzf_common_args[@]}"
    --disabled
    --bind "start:reload:build_static_menu"
    --bind "change:reload:handle_non_gemini_change {q} 2>>$LOG_FILE || true"
    --prompt 'Cheatsheet> '
  )
fi

# --- Main Logic ---
# The list generation is now fully handled by the fzf bindings in both modes.
# We pipe an empty string to fzf to start it, the bindings do the rest.

### ADDED ### Ensure flag file does not exist before starting fzf
rm -f "$RELOAD_FLAG_FILE"

selection=$(fzf "${fzf_args[@]}")

# Cleanup files on exit
rm -f "$DEBOUNCE_PID_FILE"

# Exit if no selection
if [[ -z "$selection" ]]; then
    echo "DEBUG: No selection made. Exiting."
    ### MODIFIED ### Check for reload even when selection is empty (e.g., user hits Esc after adding)
    if [ -f "$RELOAD_FLAG_FILE" ]; then
        rm -f "$RELOAD_FLAG_FILE"
        exec "$0"
    fi
    exit
fi
echo "DEBUG: User selected: '$selection'"

### MODIFIED ### Main reload logic using the flag file
if [ -f "$RELOAD_FLAG_FILE" ]; then
    rm -f "$RELOAD_FLAG_FILE"
    exec "$0"
fi

# Handle Gemini toggle
if [[ "$selection" =~ "Search with Gemini API" ]]; then
    echo "DEBUG: Handling Gemini toggle."
    if [[ "$SEARCH_WITH_GEMINI" == "true" ]]; then
        sed -i 's/SEARCH_WITH_GEMINI *= *.*/SEARCH_WITH_GEMINI="false"/' "$CONFIG_FILE"
        notify-send "Cheatsheet" "Gemini search disabled ‚úÖ"
    else
        sed -i 's/SEARCH_WITH_GEMINI *= *.*/SEARCH_WITH_GEMINI="true"/' "$CONFIG_FILE"
        notify-send "Cheatsheet" "Gemini search enabled ‚úÖ"
    fi
    exec "$0"
fi

# Handle copy all cheats
if [[ "$selection" =~ ^"Copy all cheat" ]]; then
    echo "DEBUG: Handling 'Copy all cheats'."
    jq '.' "$CHEAT_FILE" | wl-copy
    notify-send "Cheatsheet" "All cheats copied to clipboard ‚úÖ"
    exit
fi

# --- Extract and copy the actual command ---
# Trim prefix, then extract command before ‚Üí
command="${selection#üí° }"       # Remove leading üí° if present
command="${command%%‚Üí*}"         # Take everything before ‚Üí 
command="$(echo -e "$command" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"  # trim spaces

# Copy safely without expansion
printf '%s\n' "$command" | wl-copy
notify-send "Cheatsheet" "Command copied: $command ‚úÖ"

echo "--- Script finished at $(date) ---"

# Deactivate verbose mode before exiting
set +x